# 流网络

## 流网络(Flow Network)

一个有向图，源点不断产生某物质，流向消耗该物质的汇点的过程。源点以固定速度产生，汇点以同样的速度消耗。

- 流网络G=(V, E)是一个有向图，其中n=|V|, m=|E|
- 容量Capacity:每条边(u, v) ∈E 有一个非负容量c(u, v) ≥ 0.   如果 (u, v) ∉ E, 则假定c(u, v) = 0

- 流网络中两个特别的点:   
  - 发点或者源s   (无入边)
  - 收点或者汇t  （无出边） 
- 每个结点都位于从源点到汇点的某条路径上，也就是对每个结点v ∈ V, 存在一条路s->v->t 因此图为连通图，|E| ≥ |V | - 1.

### 流网络-形式化定义

G中的流f是一个实数函数 f : V × V → R ，满足:

容量限制（Capacity Capacity constraint）:  对于所有的u, v ∈ V, f (u, v) ≤ c(u, v)

反对称性（Skew symmetry）: 对于所有的u, v ∈ V, f (u, v) = - f (v, u)

流守恒性（Flow conservation）: 对于所有的u ∈ V - {s, t}, 则f (u, v)成为从顶点u到v的可行流，可以为正，为零，也可以为负。流f的值的定义为|f|=∑_v∈v f(S,v)

### 若描述卡车运输的问题。

<img src="/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/image-20221023132718367.png" alt="image-20221023132718367" style="zoom:50%;" />

Vancouver是源点s（源，发点）

Winnipeg是汇点t（汇，收点）

产品经过中间城市运输，但是每天只能有c(u, v) 箱从城市u运到v

每条边上的权值为容量（capacity）. 

### 增广路径、增广链(Augmenting paths)

流网络上的路径：一条从源点s到汇点t到路

前向弧 (Forward arc) : 弧的方向与路的方向一致

反向弧 (Backward arc): 弧的方向与路的方向相反

eg.<img src="/Users/lixiang/Downloads/我爱学习/高级算法/笔记/增广路径.png" alt="增广路径" style="zoom:50%;" />

其中路径为：s, v2, v1, v3, t

前向弧：(s, v2) (v1, v3) (v3, t)

反向弧：(v2, v1)

#### 增广路径相关概念

容量网络G = (𝑉, 𝐸, 𝑐, 𝑠, 𝑡 )， 𝑓是G上任一可行流

饱和边：流量等于容量的边

非饱和边：流量小于容量的边

零流边：流量等于0的边

非零流边：流量大于0的边

**增广路径**p 是一条从s 到 t 的边不重复对路，（不考虑边的方向情况下的路径）

如果 (u, v) 是前向弧（与路的方向一致） :  0≤f(u,v)<c(u,v)(流量小于容量，还有提升的空间，即非饱和边) 

如果 (u, v) 是反向弧: 0 <f(u,v) ≤ c(u,v)(反向流量大于0，即非零流边）

## 最大流问题

在不违背容量限制的条件下，把物质从源点传输到汇点的最大速率是多少。

## Ford-Fulkerson最大流算法

1. 从给定的初始可行流 f(u, v) = 0 开始，对所有 u, v ∈ V,初始流为0. 0
2. 找一条关于当前可行流的s-t增广链(augmenting path)。
3. 对当前增广链扩展当前的可行流，得到新的可行流。
4. 重复步骤2,3，直到没有增广链为止

### 标号法求增广路径详细步骤

为顶点标号：对于结点 𝑗标号为( 𝑙j , 𝛿𝑗 )。𝑙j 是前驱结点的标号.𝛿𝑗 是这条边剩余的流量。

(1) 对源点𝑠 标号为 (0, +∞ )

(2) 如果结点i 被标记了，则检查其邻接点 j (by DFS or BFS), <i, j> or <j, i>∈E,  如果结点 j  没有被标号

  •如果 <i, j> ∈E , f( i, j ) < c( i, j ) (非饱和边), 那么𝑗 被标为( 𝑙𝑗 , 𝛿𝑗) = (𝑖, θj)=( i, min{𝛿i, 𝑐( 𝑖,𝑗 )− 𝑓( 𝑖,𝑗)} ) 

• 如果<𝑗, 𝑖> ∈E, fji >0(非零流边), 那么结点 j 被标记为 (𝑙𝑗 , 𝛿𝑗) = (−𝑖, θj )=( -i, min{𝛿i, 𝑓( 𝑗, 𝑖 )} )

(3) 重复 (2), 直到t被标号。

(4)从t反向寻找路径，检查这条增广路上所有的标号，设置 θ = min┬jθ_j

(5) 调整前向弧的流 f(i,j ) = f(i,j)+ θ 后向弧的流f(i,j )= f(i,j)- θ

(6) 删除所有的标号，继续（2）到（5），直到无增广路

eg.

![1](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/1.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/2.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/3.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/4.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/5.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/6.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/7.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/8.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/9.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/9.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/10.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/11.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/12.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/13.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/14.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/15.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/16.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/17.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/18.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/标点法/19.png)

### FF最大流算法的改进途径

FF算法没有规定如何求s-t增广路径

改进的策略

​	保证所求增广路径具有一定性质（如最短）

​	并且能一次能求多个增广链

辅助网络，残留网络

### 残留网络

给定流网络G=(V, E)，源点为s，汇点为t，设f是G的一个可行流，一对顶点u和v，在不超过其容量的条件下，从u到v之间可以压入的额外流量就是残留容量(residual capacity)。

公式为：cf(u, v) = c(u, v) - f(u, v)

如果 c(u, v) = 16 ，f(u, v) = 11, 残留容量 cf (u, v) = 5.

如果 c(u, v) = 16 ， f(u, v) = -4, 则残留容量 cf (u, v) = 20.

从v到u有4个单位的网络流，可以通过u到v压入4个单位的流抵消它。  

### FORD-FULKERSON算法流程

因为存在阻塞流，阻塞流一旦选定不能后悔，FORD-FULKERSON算法通过反向边避免阻塞流

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片1.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片2.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片3.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片4.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片5.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片6.png)

### ![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片7.png)                       

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片8.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片9.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片10.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片11.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片12.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片13.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/ff算法/图片14.png)

## Edmonds-Karp算法

Edmonds-Karp算法使用最短路径（把残留图看成无权图，或者权值都为1）

Edmonds-Karp算法是Ford-Fulkerson算法的特例

算法时间复杂度：O(|E|2.|V|)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/EK算法/图片1.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/EK算法/图片2.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/EK算法/图片3.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/EK算法/图片4.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/EK算法/图片5.png)

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/EK算法/图片6.png)

## Dinic算法

**关键概念**：阻塞流，blocking flow

当前流是阻塞流，如果不能找到其他从源点到汇点到流

最大流是阻塞流；阻塞流不一定是最大流

阻塞流可以用最简单到方法找到

**关键概念**：层次图，level graph

1. 初始化，残留图就是原图

2. 循环：       

   a. 构建残留图的层次图       

   b.找到层次图的阻塞流（如果找不到阻塞流则停止循环）       

   c. 更新残留图

#### 算法复杂度

时间复杂度：O(m·n*2)

m是边数，n是点数最多循环n-1次每次循环O(mn)

最多循环n-1次

每次循环O(mn)

eg.

Dinic算法-初始化

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/Dinic/1.png)

Dinic算法-构建层次图

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/Dinic/2.png)

Dinic算法-找到阻塞流，更新残留图

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/Dinic/3.png)

Dinic算法-构造新的层次图

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/Dinic/4.png)

Dinic算法-找到阻塞流，更新残留图

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/Dinic/5.png)

Dinic算法-构造新的层次图

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/Dinic/6.png)

结果

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/Dinic/7.png)

## 流网络的割 (cuts)

流网络G = (V, E)的割 cut (S, T)，将V划分为 S 和 T = V - S 两部分，使得 sϵS ， tϵT.        

(S, T) = {<i, j>| <i, j> ϵE and i ϵS, j ϵT } 是图G的割

如果 f 是一个可行流，则穿过割(S, T)的网络流被定义为 f(S, T). 

![](/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/割.png)

割集(S, T)的容量，割量（The capacity of the cut）表示为c(S, T). c(S,T)=∑_<i,j>∈(S,T)▒c(i,j)

最小割集 (minimum cut )：容量最小的割集称为最小割

通过割的净流可能包括顶点间的负网络流，但割的容量完全由非负值组成

<img src="/Users/lixiang/Downloads/我爱学习/高级算法/笔记/图片/割2.png" style="zoom: 200%;" />

图中的割 ({s, v1, v2}, {v3, v4, t}) .

割的网络流量f(v1, v3) + f(v2, v3) + f(v2, v4) = 12 + (-4) + 11= 19,

容量是： c(v1, v3) + c(v2, v4) = 12 + 14= 26.



设流网络 G 源点为 s 汇点为t。 f 是 G 上的任一可行流， (S, T) 是G的割，则经过(S, T)的网络流 f(S, T) = |f|.

设流网络 G 源点为 s 汇点为t。 f 是 G 上的任一可行流， (S, T) 是G的割， f 值的上限是 G的任意割的容量.



**流与割的关系**

令 f 是网络上的flow， (S,T) 是任何s-t cut：

(1) 由 S 到达 T 的流，等于到达节点sink t 的流

(2) f 小于cut的capacity

(3) 如果 f 等于cut (S,T) capacity，则 f 是最大流， (S,T) 是最小割



**最大流最小割（Max-flow min-cut）定理**

在任何网络中，最大流 fmax 的值=最小割的capacity
